---
---

<div class="grid-background">
	<canvas id="grid-canvas"></canvas>
</div>

<script>
	function initGrid() {
		const canvas = document.getElementById('grid-canvas') as HTMLCanvasElement;
		if (!canvas) return;

		const ctx = canvas.getContext('2d');
		if (!ctx) return;

		let width = window.innerWidth;
		let height = window.innerHeight;

		canvas.width = width;
		canvas.height = height;

		const gridSize = 40;
		const perspective = 500;
		let mouseX = width / 2;
		let mouseY = height / 2;

		function handleResize() {
			width = window.innerWidth;
			height = window.innerHeight;
			canvas.width = width;
			canvas.height = height;
		}

		function handleMouseMove(e: MouseEvent) {
			mouseX = e.clientX;
			mouseY = e.clientY;
		}

		window.addEventListener('resize', handleResize);
		document.addEventListener('mousemove', handleMouseMove);

		function draw3DGrid() {
			if (!ctx) return;

			ctx.clearRect(0, 0, width, height);

			const offsetX = ((mouseX - width / 2) / width) * 50;
			const offsetY = ((mouseY - height / 2) / height) * 50;

			ctx.strokeStyle = 'rgba(59, 130, 246, 0.15)';
			ctx.lineWidth = 1;

			// Horizontal lines
			for (let i = -10; i <= 10; i++) {
				ctx.beginPath();
				const y = height / 2 + i * gridSize;
				const z = i * gridSize;

				for (let j = -20; j <= 20; j++) {
					const x = width / 2 + j * gridSize;
					const scale = perspective / (perspective + z + offsetY);
					const projX = width / 2 + (x - width / 2 + offsetX) * scale;
					const projY = height * 0.7 + (y - height / 2) * scale;

					if (j === -20) {
						ctx.moveTo(projX, projY);
					} else {
						ctx.lineTo(projX, projY);
					}
				}
				ctx.stroke();
			}

			// Vertical lines
			for (let j = -20; j <= 20; j++) {
				ctx.beginPath();
				for (let i = -10; i <= 10; i++) {
					const x = width / 2 + j * gridSize;
					const y = height / 2 + i * gridSize;
					const z = i * gridSize;
					const scale = perspective / (perspective + z + offsetY);
					const projX = width / 2 + (x - width / 2 + offsetX) * scale;
					const projY = height * 0.7 + (y - height / 2) * scale;

					if (i === -10) {
						ctx.moveTo(projX, projY);
					} else {
						ctx.lineTo(projX, projY);
					}
				}
				ctx.stroke();
			}

			// Add glow points at intersections
			ctx.fillStyle = 'rgba(59, 130, 246, 0.5)';
			for (let i = -5; i <= 5; i += 2) {
				for (let j = -10; j <= 10; j += 3) {
					const x = width / 2 + j * gridSize;
					const y = height / 2 + i * gridSize;
					const z = i * gridSize;
					const scale = perspective / (perspective + z + offsetY);
					const projX = width / 2 + (x - width / 2 + offsetX) * scale;
					const projY = height * 0.7 + (y - height / 2) * scale;

					ctx.beginPath();
					ctx.arc(projX, projY, 1.5 * scale, 0, Math.PI * 2);
					ctx.fill();
				}
			}

			requestAnimationFrame(draw3DGrid);
		}

		draw3DGrid();
	}

	if (typeof window !== 'undefined') {
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initGrid);
		} else {
			initGrid();
		}
	}
</script>

<style>
	.grid-background {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		overflow: hidden;
		z-index: 0;
		pointer-events: none;
	}

	#grid-canvas {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		opacity: 0.6;
	}
</style>
